## 2️⃣본인확인 거래 요청 정보 생성

>[!summary]   
> `clientTxId`는 본인확인 요청과 결과를 매핑하고 재사용을 방지하기 위한 **고유 식별자**입니다.
> 이 값은 요청과 응답의 일치성을 검증하고, 인증 결과 재사용을 방지하는 데 사용됩니다.
#### Step 1. 이용기관 거래 ID (clientTxId) 생성
- **Step 1-1.** 중복되지 않는 이용기관의 거래ID (clientTxId)를 생성합니다.

>[!info] 이용기관 거래 ID 생성 규칙
> - 거래ID는 최소 20자 이상 40자 이내로 생성
> - 본인확인 이용기관 거래ID 는 유일한 값이어야 하며 기 사용한 거래ID가 있는 경우 오류 발생
> - 이용기관이 고유식별 ID로 유일성을 보장할 경우 고객이 이용하는 ID사용 가능
>   
> 예시 ) `[이용기관 식별자] + [UUID]`
>
> ```
> "ORG001-550e8400-e29b-41d4-a716-4466554" 
> ```

> [!warning] **인증 결과 검증을 위한 거래ID 세션 저장**  
> **- 동일한 세션 내 요청과 결과가 동일한지 확인 및 인증결과 재사용 방지처리, 응답결과 처리 시 필수 구현**
> **- 세션 내 거래ID를 저장하여 검증하는 방법은 권고 사항이며, 이용기관의 저장매체(DB 등)에 저장하여 검증 가능**
> 
> ##### clientTxId 세션 저장
> - `clientTxId`는 인증 요청과 결과 프로세스의 일치성을 검증하기 위해 세션 또는 이용기관의 저장매체(DB 등)에 저장에 저장해야 합니다.
> - 예) 세션 저장 
>  ```java
  HttpSession session = request.getSession();
  session.setAttribute("clientTxId", clientTxId);
  session.setMaxInactiveInterval(10 * 60); // 10분 만료
> ```
> - 검증 완료 후 `clientTxId`는 즉시 사용 완료 처리(삭제)하여 재사용을 방지합니다.

#### Step 2. 본인확인 토큰요청 데이터 생성
- **Step 2-1.** 암호화 전 데이터 생성 (JSONData 생성)합니다.

- **Step 2-2.** JSON 데이터 직렬화
>[!info] JSONData 생성 및 직렬화 규칙
> 이용기관 거래 ID(clientTxId), 버전, 현재 요청 시간을 포함하는 JSON 객체를 생성하고, 이를 문자열로 직렬화합니다.
> - version : "V2"
> - clientTxId : 이용기관 거래 ID (예 : ORG001-550e8400-e29b-41d4-a716-44665544)
> - requestTime : 현재 요청 시간 (형식 : yyyyMMddHHmmss, 예: 20250318113000)
> - JSON 객체를 문자열로 직렬화하여 암호화에 사용할 텍스트 데이터를 준비합니다. (예: JSON 직렬화 라이브러리 사용, UTF-8 인코딩)
> 
> 예시 )  
> ```json
> {
>	"version" : "V2",
>	"clientTxId" : "ORG001-550e8400-e29b-41d4-a716-44665544",
>	"requestTime" : "20250318113000"
> }
> ```

- **Step 2-3.** 암호화 진행(RSA 암호화) 합니다.
	1. RSA 서버 공개키 준비
		- 공개키를 Base64 디코딩 하여 바이트 배열(byte[]) 형태로 읽어서 준비
	2. RSA 암호화 방식 설정
		   - `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` 모드(OAEP: SHA-256, MGF1: SHA-256)로 위에서 생성한 데이터(직렬화된 데이터)를 암호화
	3. Base64 인코딩 처리
		- 암호화된 데이터를 Base64로 인코딩하여 전송 가능한 문자열 형태로 변환

> [!warning] 
> **RSA-OAEP 평문 길이 제한(2048-bit 기준 약 190B 전후)**

>[!info] 
> - `serverPublicKeyBase64`는 **1️⃣ 본인확인 암복호화용 키 정보** 가이드에서 `mok_keyInfo.dat` 파일 복호화로 얻은 **ServerPublicKey** 값을 사용합니다. (요청 암호화용)
> - 공개키는 X.509 포맷으로 관리됨

#### Step 3. 결과 확인
- **Step 3-1.** Base64 인코딩된 본인확인 요청 토큰(encryptReqClientInfo)

```JAVA
"WBIF9sY4qATKJD+CrxMx3Ml7 ... cf6z+a5pX+pvebiFmt6ChieUnpZp1pLA=="
```

#### Step 4. 표준창 인증(거래) 요청정보 생성

### MOKReqClientInfo

| 이름                   | 타입     | 설명                                                                                                                                            | 필수  |
| -------------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| serviceId            | String | 본인확인 이용기관 서비스 ID  <br>(본인확인 암복호화용 키 정보 내 포함됨)                                                                                                 | O   |
| encryptReqClientInfo | String | 암호화된 본인확인 거래 요청 정보                                                                                                                            | O   |
| serviceType          | String | 이용상품 코드<br>“telcoAuth” : 휴대폰본인확인 서비스<br>"telcoAuth-LMS" : 휴대폰본인확인 LMS 서비스                                                                     | O   |
| usageCode            | String | 서비스 이용 코드<br>- 01001 : 회원가입<br>- 01002 : 정보변경  <br>- 01003 : ID찾기<br>- 01004 : 비밀번호찾기<br>- 01005 : 본인확인용<br>- 01007 : 상품구매/결제<br>- 01999 : 기타 | O   |
| retTransferType      | String | 본인확인-표준창 결과 수신 타입  (Svr to Svr)<br>- `MOKToken`: 본인확인-표준창 결과 토큰                                                                               | O   |
| returnUrl            | String | 결과 수신(표준창→이용기관) 엔드포인트<br>“https://” 포함한 URL 입력                                                                                                | O   |
| encryptVersion       | String | 본인확인-표준창 토큰 암호화 방식<br>- `V2`                                                                                                                  | O   |
> [!warning]
> - returnUrl 내에 개인정보를 절대 포함시켜서는 안됩니다.
> - 개인정보가 부분적으로 분리되어 저장 또는 처리되더라도, 이를 조합하여 개인을 식별할 수 있는 경우에는 해당 정보는 개인정보에 해당합니다.
> - (ex. hpno1=010&hpno2=1234&hpno3=5678) [휴대폰번호/성명/주민번호 등]

#### MOKReqClientInfo(거래 요청 정보) JSON

```json
{
	"serviceId": ${serviceId},
	"encryptReqClientInfo": ${encryptReqClientInfo},
	"serviceType": ${serviceType},
	"usageCode": ${usageCode},
	"retTransferType": "MOKToken",
	"returnUrl" : ${returnUrl},
	"encryptVersion" : "V2"
}
```

> 위 JSON 데이터는 실제 사용 시 문자열(JSON string) 형태로 변환하여 사용해야 합니다.

---
#### 샘플은 JAVA로 제공됩니다.
```java
import com.fasterxml.jackson.databind.ObjectMapper;  
  
import javax.crypto.Cipher;  
import javax.crypto.spec.OAEPParameterSpec;  
import javax.crypto.spec.PSource;  
import java.nio.charset.StandardCharsets;  
import java.security.KeyFactory;  
import java.security.PublicKey;  
import java.security.spec.MGF1ParameterSpec;  
import java.security.spec.X509EncodedKeySpec;  
import java.text.SimpleDateFormat;  
import java.util.*;

public class MOKTokenRequestEncryption {

	public static String generateEncryptReqClientInfo(String serverPublicKeyBase64) throws Exception {  
  
	    // Step 1: 이용기관 거래 ID (clientTxId) 생성  
	    // Step 1-1: 고유한 거래 ID 생성 (예: ORG001 + UUID)    
	    String identifier = "ORG001";  
	    //  identifier 길이에 따라 총 길이가 40자를 초과할 수 있으니 필요 시 UUID substring 길이 조정
	    String uuid = UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32); //UUID에서 32자리 추출  
	    String clientTxId = identifier + "-" + uuid; // 최소 20자, 최대 40자 내로 생성  
	    if (clientTxId.length() < 20 || clientTxId.length() > 40) {  
	        throw new IllegalStateException("clientTxId length must be between 20 and 40 characters");  
	    }  
	  
	    // Step 2: 본인확인 토큰요청 데이터 생성  
	    // Step 2-1: JSON 데이터 생성    
	    ObjectMapper mapper = new ObjectMapper();  
	    Map<String, String> data = new HashMap<>();  
	    data.put("version", "V2");  
	    data.put("clientTxId", clientTxId);  
	    data.put("requestTime", new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()));  
  
	    // Step 2-2: JSON 데이터 직렬화  
	    String jsonData;  
	    try {  
	        jsonData = mapper.writeValueAsString(data);  
	    } catch (Exception e) {  
	        throw new RuntimeException("JSON 직렬화 실패", e);  
	    }  
  
	    // Step 2-3: RSA 암호화  
	    // RSA 서버 공개키 준비    
	    byte[] publicKeyBytes = Base64.getDecoder().decode(serverPublicKeyBase64);  
	    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);  
	    KeyFactory keyFactory = KeyFactory.getInstance("RSA");  
	    PublicKey publicKey = keyFactory.generatePublic(keySpec);  
  
	    // RSA-OAEP(SHA-256, MGF1-SHA-256)로 암호화
	    OAEPParameterSpec oaepParameterSpec = new OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);  
	    Cipher rsaCipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");  
	    rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey, oaepParameterSpec);  
	    byte[] encryptedData = rsaCipher.doFinal(jsonData.getBytes(StandardCharsets.UTF_8));  
  
	    // Base64 인코딩 처리  
	    String encryptReqClientInfo = Base64.getEncoder().encodeToString(encryptedData);  
  
	    // Step 3: 결과 확인  
	    return encryptReqClientInfo;  
	}  
	// Step 4: 표준창 인증 요청정보 생성
	public static String generateMOKReqClientInfo() throws Exception {
		// 1️⃣ 본인확인 암복호화용 키 정보 파일에서 정보 가져오기 가이드에서 획득한 ServerPublicKey 사용
		String serverPublicKeyBase64 = "serverPublicKeyBase64";  
		String encryptedResult = generateEncryptReqClientInfo(serverPublicKeyBase64); 
		
		ObjectMapper mapper = new ObjectMapper();
		Map<String, String> data = new HashMap<>();
		// 1️⃣ 본인확인 암복호화용 키 정보 파일에서 정보 가져오기 가이드에서 획득한 ServiceId 사용
		data.put("serviceId", "본인확인 이용기관 서비스 ID");
		data.put("encryptReqClientInfo", encryptedResult);
		// 이용상품 코드
		// "telcoAuth" : 휴대폰본인확인  
		// "telcoAuth-LMS" : 휴대폰본인확인 LMS
		data.put("serviceType", "이용상품 코드");
		// 서비스 이용 코드
		// "01001" : 회원가입  
		// "01002" : 정보변경  
		// "01003" : ID찾기  
		// "01004" : 비밀번호찾기  
		// "01005" : 본인확인용  
		// "01007" : 상품구매/결제  
		// "01999" : 기타
		data.put("usageCode", "서비스 이용 코드");
		data.put("retTransferType", "MOKToken");
		data.put("returnUrl", "본인확인 결과를 전달할 이용기관 URL");
		data.put("encryptVersion", "V2");
		
		return mapper.writeValueAsString(data);  
	}
  
    // 테스트용 메인 메서드  
    public static void main(String[] args) throws Exception {  
		String MOKReqClientInfo = generateMOKReqClientInfo();
        System.out.println("Final MOKReqClientInfo: " + MOKReqClientInfo);  
    }  
}
```

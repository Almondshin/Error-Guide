## 1️⃣ 본인확인 암복호화용 키 정보 (mok_keyInfo.dat) 파일에서 정보 가져오기

> [!warning]  **중요**
> **키파일은 서버 내 안전한 장소에 보관**
> 서비스 등록 후 발급된 `mok_keyInfo.dat`를 안전한 서버 내 디렉토리에 보관
#### Step 1. 암호화된 키 파일 준비
- **Step 1-1.** 서비스 등록 후 발급받은 본인확인 암복호화 키 정보(예 : mok_keyInfo.dat)파일을 준비합니다.
- **Step 1-2.** 암복호화 키 정보 파일을 byte[] 배열로 읽어서 준비합니다.

> [!info] 키 파일은 본인확인 인증결과 데이터를 복호화하기 위한 암호화된 정보를 포함합니다.
#### Step 2. AES 복호화 키 및 IV 생성
 - **Step 2-1.** 암/복호화를 위한 해시함수에 SHA-256 해시 인스턴스를 생성합니다.
 - **Step 2-2.** mobileOK_password(키 파일 비밀번호)를 해싱합니다.
	 - Hash1(AES_KeyBytes) : mobileOK_password(키 파일 비밀번호)의 byte를 가지고 해싱합니다.
	 - 해싱 결과의 앞 16바이트를 AES_KeyBytes (32byte의 앞16byte)로 사용합니다.
 - **Step 2-3.** 해싱을 한 번 더 실행하여 IV(초기화 벡터) 및 AES 키의 나머지 부분을 생성합니다.
	- Hash2 : 해싱 결과(Hash1)을 한번 더 해싱합니다.
	- AES_KeyBytes (Hash1) : Hash1의 앞 16byte + Hash2의 뒤 16byte
	- AES_IvBytes (초기화 벡터 16byte) : Hash2의 앞 16byte

> [!info] 이 과정은 mok_keyInfo.dat 파일을 복호화하기 위해 AES 256bit 키와 16byte IV를 생성하는 단계입니다. 키 파생에는 SHA-256 해시를 2회 적용하여 키와 IV를 분리 생성합니다.
> 
> - AES_KeyBytes: 32바이트 AES 키 (Hash1 앞 16바이트 + Hash2 뒤 16바이트).
> - AES_IvBytes: 16바이트 초기화 벡터 (Hash2 앞 16바이트).
#### Step 3. 데이터 복호화
- **Step 3-1.** AES/CBC/PKCS5Padding 모드로 위에서 생성한 AES 키와 IV를 이용하여 데이터를 복호화합니다.
#### Step 4. 결과 확인
- **Step 4-1.** 복호화된 결과를 JSON, UTF-8 문자열로 변환

> [!warning]  중요
> **JSON 형태로 복호화가 되는지 검증 필수**

``` json
{
  "ServiceId" : "7a2d276f-2bd0-4b60-852b-b91da40dd9d3",
  "ClientPrivateKey" : "MIIEvAIBADANBgkqhkiG9w0BAQE … TcWg==",
  "ServerPublicKey" : "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ … 8DAQAB"
}
```

>[!info]
> ServiceId : 이용기관 키파일의 고유 ID (인증 요청 시 서비스 식별자로 활용됨) 
> ClientPrivateKey : 개인정보 복호화 시 사용됨 (→ `5. 본인확인-표준창 개인정보 복호화` 참고)  
> ServerPublicKey : 거래요청 시 클라이언트 정보 암호화에 사용됨 (→ `2. 본인확인-표준창 거래요청정보 생성` 참고) 

#### 샘플은 JAVA로 제공됩니다.
```java
import com.fasterxml.jackson.databind.ObjectMapper;  
  
import javax.crypto.Cipher;  
import javax.crypto.spec.IvParameterSpec;  
import javax.crypto.spec.SecretKeySpec;  
import java.nio.charset.StandardCharsets;  
import java.nio.file.Files;  
import java.nio.file.Paths;  
import java.security.MessageDigest;  
import java.util.Arrays;  
import java.util.Map; 

public class MokKeyInfoDecryption {  
  
    public static String decryptMokKeyInfo(String filePath, String mobileOKPassword) throws Exception {  
        // Step 1: 키 파일 준비  
        // Step 1-1 & 1-2: mok_keyInfo.dat 파일을 byte[]로 읽기        
        byte[] encryptedData = Files.readAllBytes(Paths.get(filePath));  
  
        // Step 2: AES 복호화 키 및 IV 생성  
        // Step 2-1: SHA-256 해시 인스턴스 생성        
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");  
  
        // Step 2-2: mobileOK_password 해싱 (Hash1)  
        byte[] passwordBytes = mobileOKPassword.getBytes(StandardCharsets.UTF_8);  
        byte[] hash1 = sha256.digest(passwordBytes); // 32바이트 해시 결과  
        byte[] aesKeyBytes = new byte[32]; // AES 키를 위한 32바이트 배열 준비  
        System.arraycopy(hash1, 0, aesKeyBytes, 0, 16); // Hash1의 앞 16바이트를 AES 키 앞부분으로 사용  
  
        // Step 2-3: 두 번째 해싱 (Hash2)으로 IV와 AES 키 나머지 부분 생성        
        byte[] hash2 = sha256.digest(hash1); // Hash1을 다시 해싱  
        System.arraycopy(hash2, 16, aesKeyBytes, 16, 16); // Hash2의 뒤 16바이트를 AES 키 뒷부분으로 사용  
        byte[] aesIvBytes = Arrays.copyOfRange(hash2, 0, 16); // Hash2의 앞 16바이트를 IV로 사용  
  
        // Step 3: 데이터 복호화        
        // Step 3-1: AES/CBC/PKCS5Padding 모드로 복호화        
        Cipher aesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");  
        SecretKeySpec secretKeySpec = new SecretKeySpec(aesKeyBytes, "AES");  
        IvParameterSpec ivSpec = new IvParameterSpec(aesIvBytes);  
        aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);  
  
        byte[] decryptedData = aesCipher.doFinal(encryptedData);  
  
        // Step 4: 결과 확인  
        // Step 4-1: 복호화된 결과를 UTF-8 JSON 문자열로 변환        
        String jsonResult = new String(decryptedData, StandardCharsets.UTF_8);  
  
        // JSON 검증 (간단히 출력으로 확인, 실제로는 JSON 파싱 후 검증 필요)  
        System.out.println("Decrypted JSON: " + jsonResult);  
        return jsonResult;  
    }  
  
    // 테스트용 메인 메서드  
    public static void main(String[] args) throws Exception {  
        String filePath = "path/to/mok_keyInfo.dat"; // 실제 파일 경로로 변경  
        String mobileOKPassword = "your_mobileOK_password"; // 실제 비밀번호로 변경  
  
        String decryptedResult = decryptMokKeyInfo(filePath, mobileOKPassword);
	    
	    // JSON 형태로 복호화되었는지 검증 (예: ServiceId, ClientPrivateKey, ServerPublicKey 포함 여부 확인)  
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> result = mapper.readValue(decryptedResult, Map.class);  
		if (result.containsKey("ServiceId") && result.containsKey("ClientPrivateKey") && result.containsKey("ServerPublicKey")) {
            System.out.println("JSON 복호화 성공");  
        } else {  
            System.out.println("JSON 복호화 실패: 올바른 JSON 형식이 아님");  
        }  
    }  
}
```

## 2️⃣본인확인 거래요청정보(토큰) 생성

>[!summary]   
> `clientTxId`는 본인확인 요청과 결과를 매핑하고 재사용을 방지하기 위한 **고유 식별자**입니다.
> 이 값은 요청과 응답의 일치성을 검증하고, 인증 결과 재사용을 방지하는 데 사용됩니다.
#### Step 1. 이용기관 거래 ID (clientTxId) 생성
- **Step 1-1.** 중복되지 않는 이용기관의 거래ID (clientTxId)를 생성합니다.

>[!info] 이용기관 거래 ID 생성 규칙
> - 거래ID는 최소 20자 이상 40자 이내로 생성
> - 본인확인 이용기관 거래ID 는 유일한 값이어야 하며 기 사용한 거래ID가 있는 경우 오류 발생
> - 이용기관이 고유식별 ID로 유일성을 보장할 경우 고객이 이용하는 ID사용 가능
>   
> 예시 ) `[이용기관 식별자] + [UUID]`
>
> ```
> "ORG001-550e8400-e29b-41d4-a716-4466554" 
> ```

> [!warning] **인증 결과 검증을 위한 거래ID 세션 저장**  
> **- 동일한 세션 내 요청과 결과가 동일한지 확인 및 인증결과 재사용 방지처리, 응답결과 처리 시 필수 구현**
> **- 세션 내 거래ID를 저장하여 검증하는 방법은 권고 사항이며, 이용기관의 저장매체(DB 등)에 저장하여 검증 가능**
> 
> ##### clientTxId 세션 저장
> - `clientTxId`는 인증 요청과 결과 프로세스의 일치성을 검증하기 위해 세션 또는 이용기관의 저장매체(DB 등)에 저장에 저장해야 합니다.
> - 예) 세션 저장 
>  ```java
  HttpSession session = request.getSession();
  session.setAttribute("clientTxId", clientTxId);
  session.setMaxInactiveInterval(10 * 60); // 10분 만료
> ```
> - 검증 완료 후 `clientTxId`는 즉시 사용 완료 처리(삭제)하여 재사용을 방지합니다.

#### Step 2. 본인확인 토큰요청 데이터 생성
- **Step 2-1.** 암호화 전 데이터 생성 (JSONData 생성)합니다.

- **Step 2-2.** JSON 데이터 직렬화
>[!info] JSONData 생성 및 직렬화 규칙
> 이용기관 거래 ID(clientTxId), 버전, 현재 요청 시간을 포함하는 JSON 객체를 생성하고, 이를 문자열로 직렬화합니다.
> - version : "V2"
> - clientTxId : 이용기관 거래 ID (예 : ORG001-550e8400-e29b-41d4-a716-44665544)
> - requestTime : 현재 요청 시간 (형식 : yyyyMMddHHmmss, 예: 20250318113000)
> - JSON 객체를 문자열로 직렬화하여 암호화에 사용할 텍스트 데이터를 준비합니다. (예: JSON 직렬화 라이브러리 사용, UTF-8 인코딩)
> 
> 예시 )  
> ```json
> {
>	"version" : "V2",
>	"clientTxId" : "ORG001-550e8400-e29b-41d4-a716-44665544",
>	"requestTime" : "20250318113000"
> }
> ```

- **Step 2-3.** 암호화 진행(RSA 암호화) 합니다.
	1. RSA 서버 공개키 준비
		- 공개키를 Base64 디코딩 하여 바이트 배열(byte[]) 형태로 읽어서 준비
	2. RSA 암호화 방식 설정
		   - `RSA/ECB/OAEPWithSHA-256AndMGF1Padding` 모드(OAEP: SHA-256, MGF1: SHA-256)로 위에서 생성한 데이터(직렬화된 데이터)를 암호화
	3. Base64 인코딩 처리
		- 암호화된 데이터를 Base64로 인코딩하여 전송 가능한 문자열 형태로 변환

> [!warning] 
> **RSA-OAEP 평문 길이 제한(2048-bit 기준 약 190B 전후)**

>[!info] 
> - `serverPublicKeyBase64`는 **1️⃣ 본인확인 암복호화용 키 정보** 가이드에서 `mok_keyInfo.dat` 복호화로 얻은 **ServerPublicKey(X.509)** 값을 사용합니다. (요청 암호화용)
> - 공개키는 X.509 포맷으로 관리됨
#### Step 3. 결과 확인
- **Step 3-1.** Base64 인코딩된 본인확인 요청 토큰(encryptReqClientInfo)

```JAVA
"WBIF9sY4qATKJD+CrxMx3Ml7 ... cf6z+a5pX+pvebiFmt6ChieUnpZp1pLA=="
```

#### 샘플은 JAVA로 제공됩니다.
```java
import com.fasterxml.jackson.databind.ObjectMapper;  
  
import javax.crypto.Cipher;  
import javax.crypto.spec.OAEPParameterSpec;  
import javax.crypto.spec.PSource;  
import java.nio.charset.StandardCharsets;  
import java.security.KeyFactory;  
import java.security.PublicKey;  
import java.security.spec.MGF1ParameterSpec;  
import java.security.spec.X509EncodedKeySpec;  
import java.text.SimpleDateFormat;  
import java.util.*;

public class MOKTokenRequestEncryption {

	public static String generateEncryptReqClientInfo(String serverPublicKeyBase64) throws Exception {  
  
	    // Step 1: 이용기관 거래 ID (clientTxId) 생성  
	    // Step 1-1: 고유한 거래 ID 생성 (예: ORG001 + UUID)    
	    String identifier = "ORG001";  
	    String uuid = UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32); //UUID에서 32자리 추출  
	    String clientTxId = identifier + "-" + uuid; // 최소 20자, 최대 40자 내로 생성  
	    if (clientTxId.length() < 20 || clientTxId.length() > 40) {  
	        throw new IllegalStateException("clientTxId length must be between 20 and 40 characters");  
	    }  
	  
	    // Step 2: 본인확인 토큰요청 데이터 생성  
	    // Step 2-1: JSON 데이터 생성    
	    ObjectMapper mapper = new ObjectMapper();  
	    Map<String, String> data = new HashMap<>();  
	    data.put("version", "V2");  
	    data.put("clientTxId", clientTxId);  
	    data.put("requestTime", new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()));  
	  
	    // Step 2-2: JSON 데이터 직렬화  
	    String jsonData;  
	    try {  
	        jsonData = mapper.writeValueAsString(data);  
	    } catch (Exception e) {  
	        throw new RuntimeException("JSON 직렬화 실패", e);  
	    }  
	  
	    // Step 2-3: RSA 암호화  
	    // RSA 서버 공개키 준비    
	    byte[] publicKeyBytes = Base64.getDecoder().decode(serverPublicKeyBase64);  
	    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);  
	    KeyFactory keyFactory = KeyFactory.getInstance("RSA");  
	    PublicKey publicKey = keyFactory.generatePublic(keySpec);  
	  
	  
		// RSA-OAEP(SHA-256, MGF1-SHA-256)로 암호화
	    OAEPParameterSpec oaepParameterSpec = new OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);  
	    Cipher rsaCipher = Cipher.getInstance("RSA/ECB/OAEPWithSha-256AndMGF1Padding");  
	    rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey, oaepParameterSpec);  
	    byte[] encryptedData = rsaCipher.doFinal(jsonData.getBytes(StandardCharsets.UTF_8));  
	  
	    // Base64 인코딩 처리  
	    String encryptReqClientInfo = Base64.getEncoder().encodeToString(encryptedData);  
	  
	    // Step 3: 결과 확인  
	    System.out.println("Encrypted Request Client Info: " + encryptReqClientInfo);  
	    return encryptReqClientInfo;  
	}  
  
    // 테스트용 메인 메서드  
    public static void main(String[] args) throws Exception {  
		// 1️⃣ 본인확인 암복호화용 키 정보 파일에서 정보 가져오기 가이드에서 ServerPublicKey 획득
        String serverPublicKeyBase64 = "serverPublicKeyBase64";  
        String encryptedResult = generateEncryptReqClientInfo(serverPublicKeyBase64);  
        System.out.println("Final Encrypted Result: " + encryptedResult);  
    }  
}
```
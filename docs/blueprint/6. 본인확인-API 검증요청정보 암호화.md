
## 4️⃣본인확인 검증요청정보(토큰) 생성

> [!warning]  **중요**
> **키파일은 서버 내 안전한 장소에 보관**
> 서비스 등록 후 발급된 `mok_keyInfo.dat`를 안전한 서버 내 디렉토리에 보관
## 휴대폰본인확인-API 검증요청 정보

> [!warning]  인증번호가 있는 상품인 경우에만 암호화(encryptMOKVerifyInfo)

#### 휴대폰본인확인 결과요청 원문 MOKVerifyInfo 생성

| 이름         | 타입     | 설명                                                                                                                 | 필수  |
| ---------- | ------ | ------------------------------------------------------------------------------------------------------------------ | --- |
| authNumber | String | 휴대폰본인확인 서비스 인증번호 및 점유인증 인증정보  <br>- SMS/LMS 인증번호 : SMS/LMS 문자로 전달받은 6자리 인증번호  <br>- SMS 소유인증 : SMS 문자로 전달받은 인증번호   |     |
# 암호화

## 본인확인 검증요청정보 암호화(encryptMOKVerifyInfo)

#### Step 1. AES 암호화 키와 IV 생성과 인증 요청 정보 암호화
- **Step 1-1.** 인증 요청 정보를 암호화하기 위해 AES 암호화 키(key)와 초기화 벡터(iv)를 생성합니다. 

>[!summary] AES 암호화 키와 IV 생성
> - 키와 IV는 난수 생성기를 사용해 무작위로 생성된 바이트 배열
> - key는 32바이트 (AES 256bit 암호화용)  
> - iv는 16바이트 (AES CBC 모드에서 사용하는 IV)
> 
> 예시) `byte[] aesKey = new byte[32]` `byte[] iv = new byte[16];`

> [!warning] 하드코딩된 값은 보안상 절대 사용하면 안됩니다, 매번 요청마다 새로 생성해야 합니다.

- **Step 1-2.** 인증요청 정보를 AES 암호화 (AES/CBC/PKCS5Padding)합니다.
	1. AES 키 및 IV 준비  
	  - 생성한 AES 키(`aesKey`)와 IV(`iv`)를 사용해서 암호화에 필요한 객체 준비  
	2. AES 암호화 알고리즘 설정 
	  - `AES/CBC/PKCS5Padding` 방식으로 설정
	3. 인증 요청 본문 암호화
	  - 인증요청 본문 (예: `MOKVerifyInfo` ) 을 UTF-8로 인코딩 하여 바이트 배열(byte[]) 형태로 변환하여 암호화
	1. Base64 인코딩 처리  
	  - 암호화된 데이터를 그대로 전송하기 어려우므로, Base64 인코딩하여 저장 (예: `encData`)
- **Step 1-3.** 해시값을 생성 (SHA-256) 합니다.

>[!summary] 해시값 생성 (SHA-256)
> - 암호화되기 전 인증 요청 본문 (예: `MOKVerifyInfo` )  문자열을 SHA-256 해시로 처리
> - 해시 결과는 Base64로 인코딩하여 문자열(hash)로 저장
> - 이 해시값은 key + iv를 묶은 평문을 만들 때 사용

#### Step 2. AES 키(key)와 IV(iv)를 안전하게 전달하기 위한 추가 암호화

- **Step 2-1.** 공개키를 준비합니다.
>[!summary] RSA 공개키
> - 공개키는 X.509 포맷이며, Base64 디코딩 후 바이트 배열로 변환 
> - 공개키는 본인확인 거래요청정보(토큰) 요청 시 본인확인 서버로부터 응답받은 JSON의 `publicKey` 필드를 말한다.
> ```json
> {
>	"encryptMOKToken" : "[RBj8YiVJ5e8lOChfhE76+AJj … pikDZMbeegv9r79uVUcMdA==",
>	"publicKey" : "MIIBIjANBgkqhkiG … N+Ey0zPfswIDAQAB",
>	"resultCode" : "2000",
>	"resultMsg" : "success"
}

- **Step 2-2.** 암호화 방식을 설정합니다.
	1. RSA 암호화 방식 설정
		- `RSA with OAEP Padding`을 사용 
>[!summary]   RSA 암호화 알고리즘 패딩 구성
>- 해시 함수: SHA-256  
>- 마스킹 함수(MGF): MGF1 (SHA-256 기반)  
>- PSource: default 값 사용 (PSource.PSpecified.DEFAULT에 해당하는 값)  
>  (SHA-256, MGF1, MGF1ParameterSpec(“SHA-256”), PSource.PSpecified.DEFAULT)

>[!warning] 이 설정은 각 언어의 RSA 암호화 함수에서 패딩 옵션으로 명시되어야 하며,  OAEP 모드를 지원하지 않는 RSA 함수는 사용할 수 없습니다.

- **Step 2-3.** key + iv를 결합하여 `keyIv` 바이트 배열(byte[])을 생성합니다.
	1. key + iv 결합 (48바이트) 
		- AES 암호화에 사용된 key(32byte) 와 iv(16byte)를 붙여서 총 48바이트의 바이트 배열을 만듦
	2. 첫 번째 구간 (0 ~ 31 바이트)
		- 앞 32바이트에는 key(AES 암호화 키)값을 복사 
	3. 두 번째 구간 (32 ~ 47 바이트)
		- 뒤 16 바이트에는 iv(AES 암호화 IV)값을 복사
	4. Base64 인코딩 처리
- **Step 2-4.** 평문을 생성 (`keyIvBase64 + '|' + hash`) 합니다.
	1. 최종 평문(`encKey`) 생성
		- `keyIv` 바이트 배열을 Base64로 인코딩해서 문자열로 변환
		- 그 문자열과 `keyIv`의 SHA-256 해시 값을 `|` 기호로 이어 붙여 하나의 문자열로 만듦
- **Step 2-5.** 평문 데이터를 RSA 방식으로 암호화합니다.
	1. 평문 문자열 변환
		- Step 2-4에서 생성한 평문 문자열(`encKey`)을 UTF-8로 인코딩해서 바이트 배열로 변환
	2. RSA 암호화 방식 설정 및 암호화 진행
		- `RSA/ECB/OAEPPadding` 모드로 변환된 바이트 배열(byte[]) 암호화 진행
 - **Step 2-6.** 암호화된 데이터를 조합하여 최종 전송 데이터를 생성합니다.  
	1. RSA 암호화 결과 인코딩  
		- Step 2-5에서 생성된 RSA 암호화 결과를 Base64로 인코딩해서 문자열로 변환  
	2. 최종 데이터 조합  (encryptMOKVerifyInfo)
		- 인코딩된 RSA 결과와 AES로 암호화한 인증 요청 데이터(`encData`)를 `'|'` 기호로 이어 붙여 최종 문자열 생성  
		- 형식: `암호화된 encKey | encData`


```java
import com.fasterxml.jackson.databind.ObjectMapper;  
  
import javax.crypto.Cipher;  
import javax.crypto.spec.IvParameterSpec;  
import javax.crypto.spec.OAEPParameterSpec;  
import javax.crypto.spec.PSource;  
import javax.crypto.spec.SecretKeySpec;  
import java.nio.charset.StandardCharsets;  
import java.security.KeyFactory;  
import java.security.MessageDigest;  
import java.security.PublicKey;  
import java.security.SecureRandom;  
import java.security.spec.MGF1ParameterSpec;  
import java.security.spec.X509EncodedKeySpec;  
import java.util.Base64;  
import java.util.Collections;  
  
public class MOKVerifyInfoEncryption {  
  
    // MOKVerifyInfo 클래스 (검증요청 정보)  
    public static class MOKVerifyInfo {  
        private String authNumber;  
  
        public MOKVerifyInfo(String authNumber) {  
            this.authNumber = authNumber;  
        }  
  
        // JSON 문자열로 변환  
        public String toJson() {  
            ObjectMapper mapper = new ObjectMapper();  
            try {  
                return mapper.writeValueAsString(Collections.singletonMap("authNumber", authNumber));  
            } catch (Exception e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
  
    // 검증요청 정보 암호화 메서드  
    public static String encryptMOKVerifyInfo(MOKVerifyInfo verifyInfo, String publicKeyBase64) throws Exception {  
        // 인증번호가 없는 경우 암호화하지 않음 (예: 휴대폰본인확인 PASS인증, ARS 점유인증)  
        if (verifyInfo == null || verifyInfo.authNumber == null || verifyInfo.authNumber.isEmpty()) {  
            return "";  
        }  
  
        // Step 1: AES 암호화 키와 IV 생성  
        SecureRandom secureRandom = new SecureRandom();  
        byte[] aesKey = new byte[32]; // 32바이트 AES 키  
        byte[] iv = new byte[16];     // 16바이트 IV  
        secureRandom.nextBytes(aesKey);  
        secureRandom.nextBytes(iv);  
  
        // Step 1-2: AES 암호화 (AES/CBC/PKCS5Padding)  
        Cipher aesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");  
        SecretKeySpec secretKeySpec = new SecretKeySpec(aesKey, "AES");  
        IvParameterSpec ivSpec = new IvParameterSpec(iv);  
        aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);  
  
        String verifyInfoJson = verifyInfo.toJson();  
        byte[] encryptedData = aesCipher.doFinal(verifyInfoJson.getBytes(StandardCharsets.UTF_8));  
        String encData = Base64.getEncoder().encodeToString(encryptedData);  
  
        // Step 1-3: SHA-256 해시 생성  
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");  
        byte[] hashBytes = sha256.digest(verifyInfoJson.getBytes(StandardCharsets.UTF_8));  
        String hash = Base64.getEncoder().encodeToString(hashBytes);  
  
        // Step 2-3: key + iv 결합 (48바이트)  
        byte[] keyIv = new byte[48];  
        System.arraycopy(aesKey, 0, keyIv, 0, 32); // 앞 32바이트는 AES 키  
        System.arraycopy(iv, 0, keyIv, 32, 16);     // 뒤 16바이트는 IV  
  
        // Step 2-4: 평문 생성 (keyIvBase64 + '|' + hash)        
        String keyIvBase64 = Base64.getEncoder().encodeToString(keyIv);  
        String encKey = keyIvBase64 + "|" + hash;  
  
        // Step 2-1: RSA 공개키 준비  
        byte[] publicKeyBytes = Base64.getDecoder().decode(publicKeyBase64);  
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);  
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");  
        PublicKey publicKey = keyFactory.generatePublic(keySpec);  
  
        // Step 2-2 & 2-5: RSA 암호화 (RSA/ECB/OAEPPadding)  
        OAEPParameterSpec oaepParams = new OAEPParameterSpec(  
            "SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT  
        );  
        Cipher rsaCipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");  
        rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey, oaepParams);  
  
        byte[] encryptedKeyIv = rsaCipher.doFinal(encKey.getBytes(StandardCharsets.UTF_8));  
        String encryptedKeyIvBase64 = Base64.getEncoder().encodeToString(encryptedKeyIv);  
  
        // Step 2-6: 최종 데이터 조합 (encryptMOKVerifyInfo)  
        return encryptedKeyIvBase64 + "|" + encData;  
    }  
  
    // 테스트용 메인 메서드  
    public static void main(String[] args) throws Exception {  
        // 예시: SMS/LMS/SMS 소유인증용 인증번호  
        MOKVerifyInfo verifyInfo = new MOKVerifyInfo("123456"); // 6자리 인증번호  
        // 공개키 (서버에서 받은 X.509 Base64 공개키)        
        String publicKeyBase64 = "your_publicKey";  
  
        // 암호화 실행  
        String encryptedResult = encryptMOKVerifyInfo(verifyInfo, publicKeyBase64);  
        System.out.println("Encrypted MOKVerifyInfo: " + encryptedResult);  
  
        // 예시: 인증번호가 없는 경우 (예: 휴대폰본인확인 PASS인증, ARS 점유인증)  
        MOKVerifyInfo emptyVerifyInfo = new MOKVerifyInfo("");  
        String emptyResult = encryptMOKVerifyInfo(emptyVerifyInfo, publicKeyBase64);  
        System.out.println("Encrypted MOKVerifyInfo (Empty): " + emptyResult);  
    }  
}
```
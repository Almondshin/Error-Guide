
## 5️⃣ 본인확인 개인정보 복호화

> [!warning]  **중요**
> **키파일은 서버 내 안전한 장소에 보관**
> 서비스 등록 후 발급된 `mok_keyInfo.dat`를 안전한 서버 내 디렉토리에 보관
### 휴대폰본인확인 인증결과 encryptMOKResult 복호화

#### Step 1. 암호화된 결과 데이터 준비
- **Step 1-1.** 서버로부터 받은 암호화된 인증결과(encryptMOKResult)를 준비합니다.
- **Step 1-2.** encryptMOKResult를 '|'로 분리하여 각각의 데이터를 추출합니다.

> [!info]  
> - encryptMOKResult는 두 부분으로 구성되며, '|' 구분자로 나누어짐
> 	- 첫 번째 부분(encryptKeyIvHashData) : RSA로 암호화된 키와 IV 정보  (Base64 인코딩)
> 	- 두 번째 부분(encryptResultData) : AES로 암호화된 실제 인증결과 데이터 (Base64 인코딩)
#### Step 2. RSA 복호화로 AES 키와 IV 추출
- **Step 2-1.** RSA 개인키를 준비합니다.
    1. 개인키를 Base64 디코딩 하여 바이트 배열(byte[]) 형태로 읽어서 준비
- **Step 2-2.** RSA 복호화 설정을 구성합니다.
    1. RSA 암호화 방식 설정
>[!summary]   RSA 암호화 알고리즘 패딩 구성
>- 해시 함수: SHA-256  
>- 마스킹 함수(MGF): MGF1 (SHA-256 기반)  
>- PSource: default 값 사용 (PSource.PSpecified.DEFAULT에 해당하는 값)  
>  (SHA-256, MGF1, MGF1ParameterSpec(“SHA-256”), PSource.PSpecified.DEFAULT)

>[!warning] 이 설정은 각 언어의 RSA 암호화 함수에서 패딩 옵션으로 명시되어야 하며,  OAEP 모드를 지원하지 않는 RSA 함수는 사용할 수 없습니다.

- **Step 2-3.** RSA 복호화를 수행합니다.
    1. encryptKeyIvHashData를 Base64 디코딩하여 바이트 배열로 변환
    2. RSA 복호화를 통해 평문(keyIvHashData)을 얻음
- **Step 2-4.** keyIvHashData를 '|'로 분리하여 base64KeyIv와 hashData를 추출합니다.

>[!info] 
>- `clientPrivateKeyBase64`는 **1️⃣ 본인확인 암복호화용 키 정보** 가이드에서 `mok_keyInfo.dat` 파일 복호화로 얻은 **ClientPrivateKey** 값을 사용합니다. (개인정보 복호화용) 
>-  개인키는 PKCS#8 포맷으로 관리됨
> 
>-  평문(keyIvHashData)은 '|'로 구분된 두 부분으로 구성
> 	- 첫 번째 부분: Base64로 인코딩된 keyIv (AES 키 + IV)
> 	- 두 번째 부분: 원문 데이터의 SHA-256 해시값 (Base64 인코딩)
#### Step 3. AES 키와 IV 준비
- **Step 3-1.** base64KeyIv를 Base64 디코딩하여 48바이트 배열(keyIv)로 변환합니다.
- **Step 3-2.** keyIv에서 AES 키와 IV를 추출합니다.

> [!info]
> 
> - 첫 32바이트: AES-256 암호화 키
> - 다음 16바이트: 초기화 벡터 (iv)

#### Step 4. AES 복호화
- **Step 4-1.** AES/CBC/PKCS5Padding 모드로 위에서 추출한 AES 키와 IV를 이용하여 데이터를 복호화합니다.
#### Step 5. 결과 확인 및 검증
- **Step 5-1.** 복호화된 결과를 JSON, UTF-8 문자열로 변환
    1. 복호화된 평문 데이터를 SHA-256으로 해싱.
    2. 해시 결과를 Base64로 인코딩하여 Step 2-3에서 얻은 hashData와 비교.

> [!warning] **중요**
> 
> **- JSON 형태로 복호화가 되는지 검증 필수**
> **- 무결성 검증 : 데이터 변조 여부 확인**

```json
{
  "siteId" : "이용기관 ID",
  "clientTxId" : "이용기관 거래 ID",
  "txId" : "본인확인 거래 ID",
  "providerId" : "서비스제공자(인증사업자) ID",
  "serviceType" : "이용 서비스 유형",
  "ci" : "사용자 CI",
  "di" : "사용자 DI",
  "userName" : "사용자 이름",
  "userPhone" : "사용자 전화번호",
  "userBirthday" : "사용자 생년월일",
  "userGender" : "사용자 성별 (1: 남자, 2: 여자)",
  "userNation" : "사용자 국적 (0: 내국인, 1: 외국인)",
  "reqAuthType" : "본인확인 인증 종류",
  "reqDate" : "본인확인 요청 시간",
  "issuer" : "본인확인 인증 서버",
  "issueDate" : "본인확인 인증 시간"
  ...
}
```

>[!warning] **중요: 이용기관 서비스 기능 처리**
>- **개인정보 검증 및 CI 확인**
 >   - 이용기관에서 수신한 개인정보의 검증 처리
 >   - 이용기관에서 수신한 CI 확인 처리
>- **개인정보 관리**
 >   - 복호화된 개인정보는 DB등 서버저장 매체에 안전하게 저장하여야 하며, 본인확인 과정에서 획득한 정보로 저장
 >   - 개인정보를 웹 브라우저로 전송할 경우, 외부 해킹 및 유출 방지를 위해 철저한 보안 처리 필수

#### 샘플은 JAVA로 제공됩니다.
```java
import javax.crypto.Cipher;  
import javax.crypto.spec.IvParameterSpec;  
import javax.crypto.spec.OAEPParameterSpec;  
import javax.crypto.spec.PSource;  
import javax.crypto.spec.SecretKeySpec;  
import java.nio.charset.StandardCharsets;  
import java.security.KeyFactory;  
import java.security.MessageDigest;  
import java.security.PrivateKey;  
import java.security.spec.MGF1ParameterSpec;  
import java.security.spec.PKCS8EncodedKeySpec;  
import java.util.Base64;

public class MOKResultDecryption {

    public static String decryptMOKResult(String encryptMOKResult, byte[] privateKey) throws Exception {
        // Step 1: 암호화된 결과 데이터 준비
        // Step 1-1 & 1-2: encryptMOKResult를 '|'로 분리
        String[] parts = encryptMOKResult.split("\\|");
        if (parts.length != 2) {
            throw new IllegalArgumentException("Invalid encryptMOKResult format");
        }
        String encryptKeyIvHashData = parts[0];
        String encryptResultData = parts[1];

        // Step 2: RSA 복호화로 AES 키와 IV 추출
        // Step 2-1 & 2-2: RSA 개인키 및 설정 준비
        Cipher rsaCipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        OAEPParameterSpec oaepParams = new OAEPParameterSpec("SHA-256", "MGF1", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT);
        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKey);
        PrivateKey rsaPrivateKey = keyFactory.generatePrivate(privateKeySpec);

        // Step 2-3: RSA 복호화
        rsaCipher.init(Cipher.DECRYPT_MODE, rsaPrivateKey, oaepParams);
        String keyIvHashData = new String(
            rsaCipher.doFinal(Base64.getDecoder().decode(encryptKeyIvHashData)),
            StandardCharsets.UTF_8
        );

        // Step 2-4: keyIvHashData 분리
        String[] keyIvHashParts = keyIvHashData.split("\\|");
        if (keyIvHashParts.length != 2) {
            throw new IllegalArgumentException("Invalid keyIvHashData format");
        }
        String base64KeyIv = keyIvHashParts[0];
        String hashData = keyIvHashParts[1];

        // Step 3: AES 키와 IV 준비
        // Step 3-1 & 3-2: keyIv 디코딩 및 키/IV 추출
        byte[] keyIv = Base64.getDecoder().decode(base64KeyIv);
        if (keyIv.length != 48) {
            throw new IllegalArgumentException("Invalid keyIv length");
        }
        byte[] key = new byte[32];
        byte[] iv = new byte[16];
        System.arraycopy(keyIv, 0, key, 0, 32); // AES 키
        System.arraycopy(keyIv, 32, iv, 0, 16); // IV

        // Step 4: AES 복호화
        // Step 4-1: AES 설정
        Cipher aesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);

        // Step 4-2: AES 복호화
        byte[] decryptedData = aesCipher.doFinal(Base64.getDecoder().decode(encryptResultData));
        String result = new String(decryptedData, StandardCharsets.UTF_8);

        // Step 5: 결과 검증
        // Step 5-1: 무결성 검증 (SHA-256 해시 비교)
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] resultHashBytes = digest.digest(result.getBytes(StandardCharsets.UTF_8));
        String computedHash = Base64.getEncoder().encodeToString(resultHashBytes);
        if (!computedHash.equals(hashData)) {
            throw new SecurityException("Hash verification failed: Data integrity compromised");
        }

        return result;
    }

    // 테스트용 메인 메서드
    public static void main(String[] args) throws Exception {
        // 예시 입력값
        // 실제 값, 개인키로 대체
        String encryptMOKResult = "base64EncryptedKeyIvHash|base64EncryptedResultData"; 
        byte[] privateKey = Base64.getDecoder().decode("clientPrivateKeyBase64");

        try {
            String decryptedResult = decryptMOKResult(encryptMOKResult, privateKey);
            System.out.println("Decrypted JSON Result: " + decryptedResult);
        } catch (Exception e) {
            System.err.println("Decryption failed: " + e.getMessage());
        }
    }
}
```